Computer Security Lab 3: Real-life DDoS incident and malware behind it
====

### **Important note: You will need provided virtual machine (Ubuntu 16.04) for task 2. For task 4 (plugin creation) as well, if you are not ready to set up sandbox by yourself.**

### UPDATE 21.9.2018:  
**If you are running Ubuntu on your own machine**, and you have some permission problems (with disk analysis plugin) run:

```shell
sudo chmod 755 /boot/vmlinuz-4.15.0-34-generic
```
Additionally, if for some reason harddrive space is not enough, check
```
sudo gparted
```
If it is possible to allocate more.

This is already fixed in the newest zip file of Ubuntu in University network drive.


## Background
This exercise is based on real-life incident, which happened some time ago in Finland. One service was target of distributed denial-of-service (DDoS), and was periodically taken down by it.

The attacker had deployed botnet to perform DDoS attack to targeted service. Botnet was created by malicious software, spread by various methods.

The malware which was used to create botnet, had some flaws and some simple weakness was exploited in targeted service, which gives us a good example for researching.

In this exercise you will learn to analyze large-sized log file, and you are able notice how DDoS-attack appears in that log file.

We will take a look for *very* simple implementation for botnet in demonstration purposes.

Further, we will analyze the software, which was used for creating botnet, by using dynamic and static analysis method.

---
Grading
---
Make a short step-by-step report (what, why and how) of following tasks, and include possible source codes and the most important command line commands used in those tasks. It's recommended to read all tasks before starting. Actual instruction for what to do, is ***in bold and italics*** on each task.

You are elgible to following grades in this exercise by doing tasks as defined. Great ideas and implementations could compensate some poorly implemented ones.
*Upper grade requires that all previous tasks have been done as well.*

It is estimated, that you are able to do Tasks 1 & 2 during lab session (4 hours).

Tasks 3 & 4 are more advanced than earlier ones. Implementation will very likely take time outside of lab.

Task|Grade/Level|Description|
----|:---:|-----------|
 [Task 1](#task-1-finding-traces-of-ddos-attack "Task 1: Finding traces of DDoS attack") | - |  Target of distributed denial of service: Analyzing the log file
[Task 2](#task-2-malware---dynamic-analysis "Malware: dynamic analysis") | 2-3 | Malware: dynamic analysis
[Task 3](#task-3-malware---static-analysis "Malware - static analysis") | 4 | Malware: Static analysis
[Task 4](#task-4 "Analysis for more complicated samples ") | 5 | Analysis for more complicated samples OR making own analysis tool

Grade 1 can be aquired by doing lecture questionnaires from the corresponding lectures.

Grade 2 (bare minimum from the lab) can be aquired by doing Task 1, Task  2A and partial analysis in 2B (Depending on, how much things you noticed).

Difficulty on tasks is expected to be raising as you go forward with them.

You should read all of the instructions, that you know what is happening, and what you actually have to do.

*Return completed tasks to your private GitHub repository!
There will be answer template or more instructions.*

---

## **Prerequisities**

We are using Ubuntu 16.04 virtual machine in this exercise. Location is described on top of Readme of this course repository.
Size of virtual machine is quite big, because there is another virtual machine inside.

Password is: *course*

Task 2 **is not** possible to do properly without provided virtual machine. It has some special environment, what you can't make yourself, unless too much is spoiled about correct answers.

Set preferrably 4GB of RAM and all processors for guest (Ubuntu) virtual machine. Intel VT-x/EPT or AMD-V/RVI must be enabled. In case you are planning to download virtual machine, and run it in your own machine, note these requirements.




## **Task 1: Finding traces of DDoS attack**

Once you have opened the virtual machine, clone course repository into **Desktop**. This location is required and mandatory that some tools are preconfigured correctly.

```
cd ~/Desktop
git clone https://github.com/CompSec-2018/CompSec.git
```


In this first task, you will analyze large-sized log file of web server, which was target of DDoS. If you have no idea, what DDoS is, you can find one good explanation [here](https://www.cloudflare.com/learning/ddos/what-is-a-ddos-attack/).

Usage of different kind of Linux tools are required for successful completion.
Opening a log file in normal text editor potentially leads crashing of virtual machine.

Logfile has 6264487 lines of data.

*You will find log file here in the folder [misc](misc) named as anonlog.zip.*
You will need to extract it.

***These Linux commands might help:** grep, less, sort, cut, awk, uniq*
`man *commandname*` and `*commandname* --help` might be helpful.


**A)  Our first mission is to identify timewindow of attack. At what time (in which second) there were the most requests for server? How many requests there were in that moment?**

**B) How servers were actually loaded/burdened? There were multiple requests for server at same time of course, but some weakness of service/server was also exploited. What was the weakness and what did the queries do to exploit it?**

**C) At what time attack started? With help of section B. information, you are able to give valid guess. There were actually two episodes for attacks. We want to know earlier one.**

**D) What IP address(es) hypotetically points towards controller of botnet itself?
It can be seperated from any other requests on the server with good reasoning. It actually caused attacker to get caught.**

## **Task 2: Malware - dynamic analysis**

*The next task will be quite long and it has been split to multiple phases, but it should give good insight, how malware might be executed in safe environment and analyzed carefully. Additionally we might understand, how
 the malware was behaving on basic level, based on results of analysis.*

We have seen some consequences what the controller of botnet was able to produce. How he/she was able to create such a botnet?

The attacker had created multiple versions of Trojan-like software.
Different versions of software was meant to target different groups of users - something what they would install into their machines.

In this case, software was mostly advertised as *Steam Code Generator 2016*; software which would give you any game you want! 
Some versions of the malwares were demostrating generation of Steam  codes, and some were demostrating something else. We are examing something else in this exercise.

In this case, malware was *League of Legends - Hacktool*, which was "hided" behind the naming *Steam Code Generator 2016*, so it could have been probably advertised as *special* product for *special* people. You were "able" to produce infinite amount of in-game currency with it.

At this point it might be already clear, that this software was indeed Trojan malware. Intention was not to give free Steam games or in-game currency for League of Legends game, instead software installed something unwanted to your pc, taking partial control of it and finally making it part of botnet.

We are going to take a glance for this League of Legends Hacktool by making dynamic analysis for it. But at first, we have to get at least *a little* familiar with tools.

### **A) Testing sandbox**

When you want to analyze malware, you don't usually want to infect your own machine. Instead you want to run it in some safe environment. Additionally easy way to undo changes would be helpful if you want to repeat process somewhat easily.

One good solution is to use virtual machines. Snapshot feature allows easy way to get back to situation, where you were before the moment of execution. Modern malwares might even detect virtual environments, and are not working there, but we are ignoring it now.

We might have been using virtual machines already somewhere at this point, but now we are taking this a little bit further.

We are automating usage of virtual machines, by using open source tool [F-Secure Sandboxed Execution Environment (SEE)](https://github.com/F-Secure/see)

F-Secure SEE implements Python based core framework for controlling and automating usage of virtual machines, therefore enabling automated execution of malware. In this case, it is opening new virtual machines under our Ubuntu 16.04 virtual machine. (Nested virtual machines)

This enables possibility to inspect virtual machine outside from it: we can capture more some essential data, when compared to just by inspecting from inside virtual machine.

SEE enables automated rollback to the state before execution, therefore we can easily repeat the process and clean anything what program caused to virtual machine.

SEE core does not offer any possibility or tools for actual analysing, instead SEE is totally plugin based, and we are using some essential plugins in later tasks. Now we are just using it to open virtual machine, and just test execution of malware.

We can find example configuration for SEE in [see](see) directory, and we will be using it.

**We stil need to** update hardware-based configurations. That will be achieved by running following command inside [see](see) directory:

```shell
virsh dumpxml win7 > conf/imageInfo/windows7.xml
```
This will regenerate configuration file for running virtual machine, based on host hardware limitations.

Additionally, let's edit 'interface' section of the xml file. It should look like this. Remove anything extra:
```xml
<interface type='network'>
  <source network='isolated'/>
</interface>
```

With good luck, this should be enough now.

### **Part A.1.**

The actual main program [sandbox.py](see/sandbox.py) for SEE is currently blank.

*We will edit this file:*

> **Now, let's follow tutorial presented [here](https://see.readthedocs.io/en/latest/tutorial_hellosandbox.html) to add some code into it, and make it to run our first virtual machine.**

We should try it out at first with the first code example.

Replace the filepath in context_factory varibale of the example code, with path to [our context file](see/conf/context.json), which you have in your machine. In practise, we are using [QEMU](https://www.qemu.org/) hypervisor to run virtual machine. Temporal run-time image is stored in *instances* folder.

Now we can just run:
```shell
python3 sandbox.py
```
At first, it might look like nothing visible happens, but actually there is virtual machine running now on the background. 

We can check it out, by opening program *Virtual Machine Manager* from the list of applications.
By clicking the running machine, and then pressing 'Open' button, we can view the machine.

Machine automatically closes in one minute.

This virtual machine is based on Windows 7, and it has some preconfigured environment as well, so sandbox could use it. Learning  of it goes out of the scope this exercise. Now we just want to use this environment to analyse things. We are using this machine for running the malware samples.

### **Part A.2.**
> **Next, let's add some more functionality for sandbox. Try out second code example provided [in tutorial.](https://see.readthedocs.io/en/latest/tutorial_hellosandbox.html)**

In this case, context configuration file is now given as parameter instead of hardcoding it. We should be able to run it now with command:

```shell
python3 sandbox.py conf/context.json
```

Window for virtual machine should appear now automatically. Additionally, Hello sandbox! text should appear on the console at the same time, when window appears.

### **Part A.3.**
 **So, let's add now some proper functionality! It's time to actually do something with virtual machine, in other words, let's run a sample malware.**

To be able upload and execute file in virtual machine, we need a plugin for it.

Let's create file named as *pluginSample.json* into *conf* folder with following content:

```json
{
      "hooks": [
        {
            "name": "hooks.commands.CommandsHook",
            "configuration": {
                "agent-port": 8080
            }
        }    ]
}

```
This file is pointing sandbox to actual plugin(s), and containing plugin specific configurations. In this case, plugin is actually located [here.](see/hooks/commands.py)

Let's except, that after that 60s wait on main program's code, virtual machine has been fully powered on before shutting down. Let's add some code after this wait time.

The plugin what we are willing to use for uploading the file and executing the content, needs IP address of guest machine. It can be aquired by adding following line into your own program (sandbox.py):

```python
context.trigger('ip_address', address=context.ip4_address)
```
The malware, what we are going to execute, is on [malware](see/malware) folder, inside [malwares.zip](see/malware/malwares.zip) file. In extracting you should use secret 'infected'.
This will probably create folder named as 'malwares', and that contains two folders, one for each malware. WannaCry malware is used in task 4.

Correct new zip -file is under SteamCodeGenerator directory. We don't need to extract this.

Add line below for extracting and execution of malware. Sample is malware's filepath in host and command is the command which will be executed on guest machine command line.
```python
context.trigger('run_sample', sample='malware/malwares/SteamCodeGenerator/30062b3ddaa291a00a348c00a03c9490879fb270d1e7e30414bf37ca1740fcff.zip', command='7z x {sample} -omalware/ && start  malware\SteamCodeGenerator2016.exe')
```
Finally, adding path of plugin configuration to Environment (edit old line):
```python
with Environment(context_factory, 'conf/pluginSample.json') as environment:
```


Now if we just add additional time for sandbox after our new code, we will have time to take a look on malware. Sandbox is uploading and executing malware automatically.

Malware is complaining, that there is no open LoL client on the machine, so we  can't test its 'in-game currency generation properties'. But that does not prevent malware to contaminate your machine.

But if you want, you can upload and execute fake [client](misc/LolClient.exe) before malware, and then you might see, what visible this program was doing it's users. Just little fancy things.
To run LolClient.exe in target system, command `cmd /c LolClient.exe` could be useful.

> In this A section, you don't have to return anything. It was just walkthrough to run something on virtual machine via SEE Sandbox, and get little insight what is going on.

### B) Dynamic analysis

Dynamical analysis (also known as behavior analysis) of  malware simply means running the malware, and inspecting the underlying system; how this program is behaving in there.

As previously mentioned, if we want to analyze some unknown or unsafe file, we want to do it in some safe environment. In this case, we are using virtual machines, and automating their usage with F-Secure SEE.

The analysis is made with plugins. We are not intrested how they are actually working: it might take way too much time. Instead, we are just interested about the results of analysis what they are producing.

Plugins are following:

* Network plugin: This enables automated network traffic capture from guest machine, by using [Wireshark](https://www.wireshark.org/). It produces a ncap file.

* Disk plugin: Based on usage of [libguestfs](http://libguestfs.org/)(with help of [VMinspect](https://github.com/noxdafox/vminspect)) and Qemu. The purpose is to analyze differences on virtual machine disk file on start and on the end of the execution. Shortly, generating a log file, which shows all changes on filesystem from the time virtual machine was turned on. (6mins on average for disk compare analysis on this task, depending on file changes. Be patient.)

* Memory plugin: Based on [Volatility](https://github.com/volatilityfoundation/volatility).  We are generating a dump from the virtual machine RAM, and then analysing it, by using different plugins of Volatility.

* There is also screenshot plugin, but not much use in this case.

Analysing disk changes and getting memory dump from whole machine is not easy to implement from inside virtual machine, and therefore tool which can automate these from outside, could be useful.


### **Running analysis**

We won't try to make main program by ourselves this time because of limited time, instead replace your previously done sandbox.py with the one provided[here.](misc/sandbox.py)



If you want to use sandbox on your own and for something else, here is short [intro.](see/README.md)

The purpose in this exercise is just to use SEE for creating analysis logfiles, and give short showcase, what malware analysis could be.

Open terminal, and change location to [see](see) folder, where sandbox.py is located. You should have replaced the content now.

.
.
.
.
.


### UPDATE 21.9.2018:  
**If you are running Ubuntu on your own machine**, and you have some permission problems (with disk analysis plugin) run:

```shell
sudo chmod 755 /boot/vmlinuz-4.15.0-34-generic
```
Additionally, if for some reason harddrive space is not enough, check
```
sudo gparted
```
If it is possible to allocate more.

This is already fixed in the newest zip file of Ubuntu in virtual disk.

.
.
.
.
.



To run sample with all plugins, here is example command:

```
python3 sandbox.py conf/context.json malware/malwares/SteamCodeGenerator/30062b3ddaa291a00a348c00a03c9490879fb270d1e7e30414bf37ca1740fcff.zip --hooks conf/hook_conf.json --command "7z x {sample} -omalware/ && start  malware\SteamCodeGenerator2016.exe"
```


Short explanation of command:
 1. Path to Main program (sandbox.py)
 2. ARG 1: Path to context configuration. (We are using QEMU Hypervisor for virtualization in this case)
 3. ARG 2: Path to malware, in this case it is Zip file. Only single file allowed
 4. ARG 3: Path to hook(plugins) configuration
 5. ARG 4: Command to be executed in target guest machine. In this case, we are extracting given zip file with 7zip to folder 'malware', and running file SteamCodeGenerator2016.exe after extraction. Filenames here cannot contain any whitespaces, they will not work.

In practise after running the command, following shoud happen:
* SEE should open virtual machine
* Network traffic recording is started
* Once VM is ready, file is uploaded and executed. Memory and disk snapshot is taken before and after malware execution.
* Then VM is waiting some time, and then closing and cleaning environment, stopping network recording
* Samples will be analysed, and logfiles will be produced. Disk analysis takes at least 5 minutes.

### **Interpret the results**

SEE is putting results on configured folders, in this case to following folders: 
* network
* memlogs
* disklogs


In network folder, you will find .pcap file, which can be read with Wireshark.

In memlogs folder, we have taken three different analysis from memory dumps (before, and after malware execution) Processes, mutants (mutexes) and active network connections before and after malware execution.
  * psscan logs contains process information before and after malware execution
  * mutantscan logs contains mutexes before and after malware execution
  * netscan logs contains open connections before and after malware execution 

In disklogs folder, there is new .json file, which shows all diskchanges on virtual machine. 

> ***Based on these files, answer to following questions:***



* ***Based on analysing network traffic and connections - shortly describe what malware is doing***

  * ***Malware is connecting to some domain, which one?***
  * ***What it did at first with domain?***
  * ***After that, some kind of harmful cycle started. Can you describe it?***
  * ***Describe which details in result files gave required information***

  **TIP:** Interesting results start after uploading the malware. Can you find this place from .pcap file?

* ***Compare start and end logs in memlogs folder***

  * ***What are mutexes in programs, and why are we analysing them?***
  * ***Which new processes were spawned?***
  * ***If you compare mutexes, what are they telling about the program we launched?***
    * In this case, not much, but it is good to know concept. This malware is not using spefic mutex name. But the difference in amount could indicate something.
  * ***What are differences in netscans telling?***

* ***Based on disk analysis, can you guess what files malware created? What entries in registry it edited? Why it was useful for malware to edit these entries?***
  * Known files are in agent/malware folder in Desktop on sandbox machine. We should ignore these. They came from extraction.
  * Process analysis could help a bit to find correct executables. Is there some other new files in same directory?
  * For registry entries, you should limit the time window for searchs - look for registers just after the time of execution of malware and little bit after. Process names could help a bit as well.
  * It is recommended to paste these JSON objects directly to your template, which shows correct information

### C) **Inspecting the server (Command & Control center)**

Based on results, we know the server whom malware was connecting to.

Additionally, we should know how the bot was controlled automatically.

**Based on this information, can you say what information bot got from the server? Show all details.**

Once malware was contaminated the machine, it started an attack immediately by using UDP protocol in this case. The target happens to be some local place.

**Create simple UDP client on Ubuntu host, which receives and prints data in this location. Use 1024 byte buffer size.**.

Run your UDP client and run sandbox malware execution normally. If you have correct IP and port in UDP client, you should be able to see the content of DDoS attack.

NOTE: This is just demonstration purposes, to see what traffic might look like on receivers end.

You can try out to start multiple instances of sanbox and malware executions. (Just open multiple terminals, and run sandbox. You can add some time into them, so they won't close too fast. Take care of not opening too many.)
Can you notice difference on your UDP client? 

*You have to disable some plugins (memory and disk analysis), because we have limited size on computer's virtual disk.*

> **Provide a screenshot from the result(When you are receiving traffic to terminal). Show all the details, what malware was getting from server.**

This C part was mostly meant for demonstration and to prove that you were able to find out correct information from analysis.

## **Task 3: Malware - static analysis**

Previously we have performed dynamic analysis for malware: inspecting the behavior of the malware by executing it.

Another way for analysing is to perform static analysis - we are not executing the malware, instead we are looking at the file(s) itself.

At first glance, if we haven't got much experience about reverse engineering, we might be seeing just some .exe files, and have no idea how to start.

But with some correct tools, we might see a lot, *particularly* in this case!

Let's see what basic Linux command *file* has to say:

```shell
$ file SteamCodeGenerator2016.exe
SteamCodeGenerator2016.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows
```

Looks like that we are probably facing .Net assembly.

One good tool for reversing these kind of executables is [dnSpy.](https://github.com/0xd4d/dnSpy), and we are using it as an example in this case. You should download it.

*NOTE: Download release zip, not direct source.*

It is portable tool, which is fully working assembly editor on Windows environment.
In Linux, we can use some of the properties of it, like console part.
We can decompile executables with it, which is enough for us.

Example for decompiling in Linux environment.
Go to dnSpy root directory:
```shell
mono dnSpy.Console.exe -o your/output/path path/to/your/malware.exe 
```
You will need to install [mono](https://www.mono-project.com) to your enviroment, if you want repeat it on another Linux than the one we have provided. Make sure, that you have at least Mono version 5. 

Update: In pre-given old version of Ubuntu 16.04, there is old version of mono. You can update it by following instructions of 16.04 here: [https://www.mono-project.com/download/stable/#download-lin](https://www.mono-project.com/download/stable/#download-lin)

And then:
```
sudo apt install mono-devel
```

Once we disassemble these files, we can actually see whole source code as it's written. It might take couple of minutes to decompile, depending on file, so patience is required. The biggest file might take 10mins or more.

Files are not protected at all.

This malware was written in Visual Basic (we can see code as C#) and looks like it has been Microsoft Visual Studio project.

**Now, the intention of this task is to write short report what program is actually doing.** Since we can read program mostly in C#, it shouldn't be hard at all. (In most cases malwares are written in C language or protected somehow, and there we might need to read pure machine instructions instead.)

There should be some exactly same things, what we tought there to be, based on dynamic analyis, if we did it right.

You are free to use any tools you want, as long as you are not analysing in your host system in unsafe environment. Even though this malware is not dangerous anymore, it's good to have principles.

>**Answer *at least* to these questions in your report:**

### A) What's the role of SteamCodeGenerator.exe, keycrack.exe and steam-dll-pro.exe?

### B) How are they trying to hide their current/upcoming activites?

### C) What's the role of anti-cheat-bypass-tool.exe in Data folder?

* We are particularly interested about this file.
* This file contains actually two additional binaries. What are their names?
* **Find a way** to reverse these files as well, and include the general purposes of these files as well to your report. Additionally:
  * How bots were controlled? There were at least two ways, describe at least the automatic approach.
  * Some source code or ideas of some common DDoS tools have been used in this malware. Describe three of them. It's enough to identify tools, you can look information about them elsewhere.
  * Malware actually contains hidden GUI for DDoS tools it is using. Can you find and use it? Describe how you did it.

### D) How well you were able to gather information from malware with dynamic analysis when compared to full reveal from source code? (optional question, does not affect grade)

## Task 4:

Implement **one** of the described following tasks, and make step-by-step report (what,why and how) including source files, for what you did:

* Ever heard about WannaCry malware? In last year (2017), this malware caused a lot of troubles in hospitals and other organisations. This malware was ransomware attack, and encrypted all the importants files of machine. It exploited some vulneralibities, which gave it self-spearding properties, making it a *worm*. Luckily there was a flaw (or intended property), which was so called *kill switch*, and stopped the spreading of malware in the cases, when machine was able to connect internet. Every time when malware was executed, it looked for some domain. Based on result malware did something. 
**In this task, we will take of look for original [*dropper*](https://en.wikipedia.org/wiki/Dropper_(malware)) of WannaCry. Only this specific dropper contained so called kill-switch.**

    * **Your task is to make static analysis for this dropper, and make step-by-step report, how you can find location of domain name of kill-switch. It should not be too hard, since you know that it exists. Explain this function, which contains kill switch.**

    * Explanation contains how you found the URL and therefore the function. What is the logic of this function? How kill-switch worked?
    What other functions are called in this function? Are functions from other library?
    
    * You can use (and it is recommended to use) for example [radare2](https://github.com/radare/radare2) for reverse engineering this executable. In practise, we are disassembling binary to machine instructions, and looking the code of malware in assembly language.
    Radare2 will be used in future as well.

    * Cheatsheet for Radare2 can be found [here.](https://github.com/radare/radare2/blob/master/doc/intro.md)

    * If you have no idea how to start, you can run this malware in sandbox as well, and get URL from there. This is not necessary. *But you can do it anyway, if you want to see, what this malware is doing for machine in practice.*

    *  **Some tips**: Can you find url, just by looking from *strings* in malware's binary? Further, can you find, where this string is re

* **Make** a very simple plugin/hook for F-secure SEE sandbox, and answer to given questions. The purpose of the plugin is following:

  * Calculate MD5 -, SHA-1 - and SHA-256 hash for given binary(ies) on execution. (Zip file can be calculated as well.)

  * Explain shortly as well, what is the purpose of hashes, and why they have been used. Why we are calculating three different hashes?

  * Use [VirusTotal Public API v2.0](https://www.virustotal.com/en/documentation/public-api/) to get possible existing information from VirusTotal for calculated hashes. In other words. your program is making HTTP request to the API, sending hashes, and storing/showing responses.

  * Send only one hash key. After response, compare if all  calculated hash keys are match for they keys from response, in case there is match for malware (given hash key). Which hash key you chose, and why?

  * Program should make simple log file about results.

  * You can use following API key, if you don't want to create own account: cc36b7771c0c738d7923b3209b6ae6c37a868e9412b3c2dd4109b10bda8f4f6e

  * Note, that requests are limited for 4 per one minute for one public API key, you might need your own account from where you are able to get own key. Just create account, and key can be found from your profile.

  * You have to edit file [hook_conf](see/conf/hook_conf.json) to add your plugin. You can mimic configuration of other plugins.

  * Add your plugin to [hooks folder](see/hooks). Make plugin to inherit [Hook interface](https://github.com/F-Secure/see/blob/master/see/interfaces.py) to get it work.

  * Use your plugin in main program [sandbox.py](see/sandbox.py)

  * **Return plugin file, screenshot of information it provides when running in sandbox/or from logfile it provided, and explanation about hashes. You can explain as comments in plugin file, what you are actually doing in code.**


* **Something interesting** in botnets or malwares, but we haven't dealt with it yet? Feel free to implement and show us what you got. **Your task has to be approved by assistant before you can start doing it.** Depending on estimated workload, this task could be extendable to final coursework.
